unit xbl; interfaceuses  OTypes,Math { XLine,XAvia};type  TEllipsoid = record    A,Alfa, B,F,Es,E: Extended  end;const  Ellipsoids_Max = 22;  Ellipsoids: array[0..Ellipsoids_Max] of TEllipsoid =    ((A:6378245;     Alfa:298.3),     (A:6378245;     Alfa:298.3),              // [KA] Krasovsky 1940     (A:6378388;     Alfa:298.26),             // [WD] WGS 1972     (A:6378200;     Alfa:298.3),              // [HE] Helmert 1906     (A:6378270;     Alfa:297.0),              // [HO] Hough 1960     (A:6378249.145; Alfa:293.465),            // [CD] Clark 1880     (A:6378206.4;   Alfa:294.9786982),        // [CC] Clark 1866     (A:6377397.155; Alfa:299.1528128),        // [BR] Bessel 1841     (A:6377483.865; Alfa:299.1528128),        // [BN] Bessel-N 1841     (A:6378137;     Alfa:298.257223563),      // WGS-1984     (A:6377563.396; Alfa:299.3249646),        // [AA] Airy 1830     (A:6377340.189; Alfa:299.3249646),        // [AM] Modified Airy     (A:6377276.345; Alfa:300.8017),           // [EA] Everest 1830     (A:6377309.613; Alfa:300.8017),           // [EE] Everest 1948     (A:6377301.243; Alfa:300.8017),           // [EC] Everest 1956     (A:6377298.556; Alfa:300.8017),           // [EB] Everest Brunei     (A:6377309.613; Alfa:300.8017),           // [EF] Everest Pakistan     (A:6378137;     Alfa:298.257222101),      // [RF] GRS 1980     (A:6378160;     Alfa:298.247),            // [ID] Indonesian 1974     (A:6378388;     Alfa:297),                // [IN] International 1924     (A:6378155;     Alfa:298.3),              // [FA] Modified Fischer 1960     (A:6378160;     Alfa:298.25),             // [SA] South American 1969     (A:6378160;     Alfa:298.25)              // [AN] Australian    );var  Small: Extended;  pi2,pi_2,pi_4: Extended;  c_: TEllipsoid;function Ellipsoids_Count: Integer; stdcall;function Set_Ellipsoid(elp: Integer): Integer; stdcall;function c_RO(Fi: double): Extended;procedure XY_to_BL(x,y, lc,b1,b2: double; elp,prj: byte; var b,l: double); stdcall;procedure BL_to_XY(b,l, lc,b1,b2: double; elp,prj: byte; var x,y: double); stdcall;procedure BL_BL(b,l: double; elp,elp_: Integer;                v,v_: PDatum; out b_,l_: double); stdcall;procedure bl_to_xyz(b,l,h: Double; elp: Integer;                    out x,y,z: Double); stdcall;function xyz_to_bl(x,y,z: Double; elp: Integer;                   out _b,_l,_h: Double): Boolean; stdcall;implementationfunction Ellipsoids_Count: Integer;begin  Result:=Ellipsoids_Maxend;function elp_(elp: Integer): Integer;begin  if elp < 0 then elp:=0;  if elp > Ellipsoids_Max then elp:=0;  Result:=elpend;function Set_Ellipsoid(elp: Integer): Integer;begin  Result:=elp_(elp);  c_:=Ellipsoids[Result];end;procedure Ellipsoids_Init;var  i: Integer;begin  for i:=0 to Ellipsoids_Max do  with Ellipsoids[i] do begin    F:=1/Alfa; B:=A*(1-F);    Es:=2*F - F*F; E:=Sqrt(Es);  end;  pi2:=2*Pi; pi_2:=Pi/2; pi_4:=Pi/4;  Small:=Pi/180/60/60/100;  c_:=Ellipsoids[1]end;function c_RO(Fi: double): Extended;var  s,c: Extended;begin  SinCos(Fi, s,c);  Result:=c_.A * c / Sqrt(1 - c_.Es*s*s)end;procedure gk_BL_XY(B,L, L0: double; out X,Y: double);var  N,N1,RAS,A2,A4,A6,F,Z,P,R,ALF,TZ,TZ2,TH,T2,  a11,a21,a31,b11,b21,b31,c11,c21,c31,d11,d21,d31,  K2,K4,K6,LL,LLL: double; Sign: Boolean;begin  N:=c_.F/(2-c_.F);  Sign:=B < 0; B:=Abs(B);  N1:=Sqr(N); R:=c_.A*(1+N1/4+N1*N1/64)/(1+N);  A2:=N/2-N1*(2/3)+N*N1*(5/16);  A4:=N1*13/48-N*N1*3/5;  A6:=N*N1*61/240;  K2:=2*(N-N1/3-N*N1*2/3);  K4:=N1*5/3-N1*N*16/15;  K6:=N1*N*26/15;  LLL:=ABS(L); IF LLL >= Pi THEN  begin LLL:=pi2-LLL; L:=-LLL END;  IF L < 0 THEN LL:=L+pi2 ELSE LL:=L;  IF Abs(L0) >= Pi THEN L0:=L0-pi2;  IF L0 < 0 THEN L0:=L0+pi2; RAS:=LL-L0;  F:=B-K2*SIN(2*B)+K4*SIN(4*B)-K6*SIN(6*B);  TZ:=(Sin(F)/Cos(F))/Cos(RAS); TZ2:=Sqr(TZ);  Z:=ArcTan(TZ); TH:=COS(F)*SIN(RAS);  T2:=Sqr(TH); P:=Ln((1+TH)/(1-TH))/2;  a11:=2*TZ/(1+TZ2); b11:=(1-TZ2)/(1+TZ2);  c11:=2*TH/(1-T2); d11:=(1+T2)/(1-T2);  a21:=2*a11*b11; c21:=2*c11*d11;  b21:=1-2*Sqr(a11); d21:=1+2*Sqr(c11);  a31:=a11*b21+a21*b11; c31:=c11*d21+c21*d11;  b31:=b11*b21-a11*a21; d31:=d11*d21+c11*c21;  X:=R * (Z+A2*a11*d11+A4*a21*d21+A6*a31*d31);  Y:=R * (P+A2*b11*c11+A4*b21*c21+A6*b31*c31);  if Sign then X:=-Xend;procedure gk_XY_BL(X,Y, L0: double; out B,L: double);var  Sign: Boolean; N,N1,B2,B4,B6,F,Z,P,R,  a11,a21,a31,b11,b21,b31,c11,c21,c31,d11,d21,d31,  K2,K4,K6,U,V,sp,chp,SinF,TanL: double;begin  N:=c_.F/(2-c_.F);  Sign:=X < 0; X:=Abs(X);  N1:=Sqr(N); R:=c_.A*(1+N1/4+N1*N1/64)/(1+N);  B2:=N/2-N1*(2/3)+N*N1*(37/96); B4:=N1/48+N*N1/15;  B6:=N*N1*17/480; K2:=2*(N-N1/3-N*N1);  K4:=N1*7/3-N1*N*8/5; K6:=N1*N*56/15;  U:=X/R; V:=Y/R; a11:=Sin(2*U); b11:=Cos(2*U);  a21:=2*a11*b11; b21:=1-2*(a11*a11);  a31:=a11*b21+a21*b11; b31:=b11*b21-a11*a21;  c11:=(exp(2*V)-exp(-2*V))/2; d11:=sqrt(1+sqr(c11));  c21:=2*c11*d11; d21:=1+2*sqr(c11);  c31:=c11*d21+c21*d11; d31:=c11*c21+d11*d21;  Z:=U-B2*a11*d11-B4*a21*d21-B6*a31*d31;  P:=V-B2*b11*c11-B4*b21*c21-B6*b31*c31;  sp:=(exp(P)-exp(-P))/2; chp:=sqrt(1+Sqr(sp));  SinF:=Sin(Z)/chp; F:=ArcSin(SinF);  TanL:=sp/Cos(Z); L:=ArcTan(TanL);  B:=F+K2*Sin(2*F)+K4*sin(4*F)+K6*sin(6*F);  if sign then B:=-B;  L:=L + L0;end;procedure m_BL_XY(B,L, B0: double; var X,Y: double); stdcall;var  e,p,u,tg,eps: double; sign: Boolean;begin  sign:=B < 0; B:=Abs(B);  e:=c_.E; p:=c_RO(Abs(B0));  eps:=Pi/180/60/60;  if Abs(B-Pi_2) < eps then  B:=Pi_2-eps;  tg:=Tan(Pi/4 + ArcSin(e*Sin(B))/2);  u:=Tan(Pi/4 + B/2) / Exp(e*Ln(tg));  X:=p*Ln(u); Y:=p*L;  if sign then X:=-Xend;procedure m_XY_BL(X,Y, B0: double; var B,L: double); stdcall;const  eps = 0.0000001;var  i: integer; grad,old: double;  e,fi,p,x2,dX,u,tg: double; sign: Boolean;begin  sign:=X < 0; X:=Abs(X);  e:=c_.E; p:=c_RO(Abs(B0));  grad:=Pi/180; fi:=0; i:=0; dX:=-x;  for i:=1 to 1024 do begin    tg:=Tan(Pi/4 + ArcSin(e*Sin(fi))/2);    u:=Tan(Pi/4 + fi/2) / Exp(e*Ln(tg));    if u < eps then Break;    x2:=p*Ln(u); Old:=dX; dX:=x2-x;    if Abs(dX) > 111000 then begin      if (Old < 0) <> (dX < 0) then      grad:=grad/2;      if dX > 0 then fi:=fi-grad      else fi:=fi+grad    end else    if Abs(dX) > 0.01 then      fi:=fi-(dX/30/36000*grad)    else      Break;  end;  if sign then fi:=-fi;  B:=fi; L:=y/p;end;//  Вычисление геоцентрических координат по геодезическимprocedure bl_to_xyz(b,l,h: Double; elp: Integer;                    out x,y,z: Double);var  e2, c,s, cl,sl, n: Extended;begin  e2:=c_.Es;  SinCos(b, s,c);  SinCos(l, sl,cl);  n:=c_.A / Sqrt(1 - e2 * s * s);  x:=(n + h) * c * cl;  y:=(n + h) * c * sl;  z:=(n * (1 - e2) + h) * send;//  Вычисление геодезических координат по геоцентрическимfunction xyz_to_bl(x,y,z: Double; elp: Integer;                   out _b,_l,_h: Double): Boolean;const  eps1 = 0.000001;  eps2 = 0.000000001;var  sx, sy, sz: Boolean; i: Integer;  a,b, a2,b2,a3,b3,r, d,d1,d2,z1,z2, e2, c2,s2: Extended;  f,l, c,s, m, p,q, u,v, df: Extended;begin  Result:=false;  _b:=0; _l:=0; _h:=0;  a:=c_.A; a2:=Sqr(a);  b:=c_.B; b2:=Sqr(b);  e2:=c_.Es;  d2:=Sqr(x) + Sqr(y); d:=0;  if d2 > eps1 then d:=Sqrt(d2);  z2:=Sqr(z); r:=d2 + z2;  if r > a2 / 2.0 then  if r < a2 * 1.5 then begin    sx:=x < 0; x:=Abs(x);    sy:=y < 0; y:=Abs(y);    sz:=z < 0; z:=Abs(z);    if x < Eps1 then      l:=0    else      l:=Arctan(y/x);    if sx then l:=l+Pi;    if sy then l:=-l;    c2:=d2 / a2 + z2 / b2;    r:=Sqrt(a2 * c2 - e2 * d2);    if b * d > 0.7 * a * r then      f:=ArcSin((a * z) / (b * r))    else      f:=ArcCos((b * z) / (a * r));    for i:=1 to 16 do begin      SinCos(f, s,c);      c2:=c * c; s2:=s * s;      r:=Sqrt(a2 * c2 + b2 * s2);      a3:=a2 / r;  b3:=b2 / r;      m:=a3 * (b3 / r);      d1:=a3 * c; z1:=b3 * s;      p:=d - d1; q:=z - z1;      u:=q * c - p * s;      v:=p * c + q * s;      df:=Arctan(u / (m + v));      f:=f+df;      if Abs(df) < EPS2 then break;    end;    if sz then f:=-f;    _b:=f; _l:=l; _h:=v;    Result:=true  endend;procedure BL_BL(b,l: double; elp,elp_: Integer;                v,v_: PDatum; out b_,l_: double); stdcall;var  from_dat,to_dat,from_idx,to_idx: Integer;  dX,dY,dZ, a1,b1,a2,b2, es1,es2, h1: Double;  vx,vy,vz, vx_,vy_,vz_: Integer;  phi1, lam1, M, N, temp: Double;  sinphi, cosphi, sinlam, coslam: Extended;  Dlat, Dlng, Dh, Da, Df: Double;begin  b_:=b; l_:=l;  vx:=0; vy:=0; vz:=0;  if Assigned(v) then begin    vx:=v.x; vy:=v.y; vz:=v.z;  end else  if elp = 0 then begin    vx:=28; vy:=-130; vz:=-95  end;  vx_:=0; vy_:=0; vz_:=0;  if Assigned(v_) then begin    vx_:=v_.x; vy_:=v_.y; vz_:=v_.z;  end else  if elp_ = 0 then begin    vx_:=28; vy_:=-130; vz_:=-95  end;  if elp = 0 then elp:=1;  if elp_ = 0 then elp_:=1;  if (elp > 0) and (elp_ > 0) then  if elp <= Ellipsoids_Max then  if elp_ <= Ellipsoids_Max then  if (elp <> elp_)  or (vx <> vx_)  or (vy <> vy_)  or (vz <> vz_) then begin    from_dat:=elp; to_dat:=elp_;    DX:=vx - vx_; DY:=vy - vy_; DZ:=vz - vz_;    from_idx:=elp; to_idx:=elp_;    a1:=Ellipsoids[from_idx].A;    b1:=Ellipsoids[from_idx].B;    a2:=Ellipsoids[to_idx].A;    b2:=Ellipsoids[to_idx].B;    // get eccentricity squared    es1:=Ellipsoids[from_idx].Es;    es2:=Ellipsoids[to_idx].Es;    // calculate delta major radius    Da:= a2 - a1;    // calculate delta flattening    Df:=Ellipsoids[to_idx].F - Ellipsoids[from_idx].F;    phi1:=b; lam1:=l; h1:=0;    // calculate sin and cos of lat and lng    SinCos(phi1, sinphi,cosphi);    SinCos(lam1, sinlam,coslam);    // calculate M and N    temp:= 1.0 - es1 * sinphi * sinphi;    M:= a1 * (1.0 - es1) / Power(temp,1.5);    N:= a1 / sqrt(temp);    // calculate delta latitude    temp:=Sqrt(1.0 - es1);    Dlat:=(-DX * sinphi * coslam - DY * sinphi * sinlam +          DZ * cosphi + Da  * (N * es1 * sinphi * cosphi) / a1 +          Df * (M / temp + N * temp) * sinphi * cosphi) / (M + h1);    while Dlat > Pi do Dlat:=Dlat - Pi;    // calculate delta longitude    Dlng:=(-DX * sinlam + DY * coslam) / ((N + h1) * cosphi);    // save new latitude, longitude    b_:=b + Dlat; l_:=l + Dlng;    // calculate delta height    Dh:=DX * cosphi * coslam + DY * cosphi * sinlam + DZ * sinphi -        Da * (a1 / N) + Df * temp * N * sinphi * sinphi;  endend;function b_Range(b: Double): Double;begin  Result:=Max(-Pi_2,Min(Pi_2,b))end;function abs_b(b: Double): Double;begin  Result:=Min(Pi_2,Abs(b))end;procedure Calc_U_R(fi: Extended; out U,R: Extended);var  c,s, n,  B, Rx: Extended;begin  SinCos(fi, s,c);  B:=c_.E * s; n:=1/Sqrt(1-Sqr(B));  B:=Arctan( B * n );  Rx:=exp(c_.E*Ln(1/Tan(pi_4 + B/2)));  U:=Rx * Tan(pi_4 + fi/2);  R:=c_.A * n * c;end;function conus_b2(var b1,b2: Double): Boolean;var  _b1,_b2,dg: Double;begin  Result:=b1 < 0;  b1:=abs_b(b1);  b2:=abs_b(b2);  _b1:=b1; _b2:=b2;  if _b2 < _b1 then begin    _b1:=b2; _b2:=b1  end;  dg:=Pi/180*10;  if _b2 < _b1+dg then begin    _b2:=_b1+dg; if _b2 >= pi_2 then begin      _b2:=pi_2-dg; _b1:=_b2-dg*6    end  end;  b1:=_b1; b2:=_b2;end;// Длина дуги от экватора до параллели Fifunction c_SO(B: double): double;var  Y: Double;begin  gk_BL_XY(B,0,0, Result,Y)end;function conus_dl(L,Lc: Extended): Extended;begin  Result:=L - Lc;  while Result < -Pi do Result:=Result + Pi2;  while Result > Pi do Result:=Result - Pi2end;var  conus1: record     _alf,_C,_RO1: Extended;     _C2,_C4,_C6,_C8: Extended;     _B1,_B2,_L1: Double;   end;procedure conus1_Init(b1,b2,l1: Double);var   Fx,Ux,Rx,U,U1,R1,U2,R,R2,RO: Extended;   e2,e4,e6,e8: Extended;begin  with conus1 do  if (_B1 <> b1)  or (_B2 <> b2)  or (_L1 <> l1) then begin    _B1:=b1; _B2:=b2;    conus_b2(b1,b2); _L1:=l1;    Calc_U_R(b1, U1,R1);    Calc_U_R(b2, U2,R2);    _alf:=(Ln(R1)-Ln(R2))/(Ln(U2)-Ln(U1));    Fx:=ArcSin(_alf);    Calc_U_R(Fx, Ux,Rx);    _C:=Sqrt(R1*Rx*Exp(Ln(U1*Ux) * _alf)) / _alf;    _RO1:=_C/Exp(Ln(U1) * _alf);    e2:=c_.Es; e4:=sqr(e2);    e6:=e2*e4; e8:=sqr(e4);    _C2:=e2/2+5/24*e4+e6/12+13/360*e8;    _C4:=7/48*e4+29/240*e6+811/11520*e8;    _C6:=7/120*e6+81/1120*e8;    _C8:=4279/161280*e8;  endend;procedure conus1_BL_XY(b,l: Double; out x,y: Double);var   p,u,dl, sin,cos: Extended;begin  with conus1 do begin    Calc_U_R(b,u,p);    p:=_C/Exp(Ln(u) * _alf);    dl:=conus_dl(l,_L1);    SinCos(_alf*dl, sin,cos);    x:=_RO1 - p*cos; y:=p*sin;  endend;procedure conus1_XY_BL(x,y: Double; out b,l: Double);var  u2,fi: Extended;begin  with conus1 do begin    x:=_RO1 - x;    if Abs(x) < 0.1 then l:=_L1 else    l:=ArcTan2(y,x)/_alf + _L1;    u2:=Sqr(Exp(Ln(_C/ Hypot(x,y) ) / _alf));    fi:=ArcSin((u2-1)/(u2+1));    b:=fi + _C2*sin(2*fi) + _C4*sin(4*fi) +            _C6*sin(6*fi) + _C8*sin(8*fi)  endend;type  RC_ru = record     _alf,_C,_RO1: Extended;     _B1,_B2,_L1: Double;   end;procedure conus_ru_BL_XY(b,l: Double; const rc: RC_ru; out x,y: Double);var  p,dl, sin,cos: Extended;begin  p:=rc._C - c_SO(b);  dl:=conus_dl(l,rc._L1);  SinCos(rc._alf * dl, sin,cos);  x:=rc._RO1 - p*cos; y:=p*sin;end;procedure conus_ru_XY_BL(x,y: Double; const rc: RC_ru; out b,l: Double);var  p: Extended;begin  x:=rc._RO1 - x; p:=Hypot(x,y);  gk_XY_BL(rc._C-p,0, 0, b,l);  if Abs(x) < 0.1 then l:=rc._L1 else  l:=ArcTan2(y,x)/rc._alf + rc._L1;end;var  conus2: RC_ru;procedure conus2_Init(b1,b2,l1: Double);begin  with conus2 do  if (_B1 <> b1)  or (_B2 <> b2)  or (_L1 <> l1) then begin    _B1:=b1; _B2:=b2;    conus_b2(b1,b2); _L1:=l1;    _alf:=(c_RO(b1)-c_RO(b2))/(c_SO(b2)-c_SO(b1));    _C:=c_RO(b1)/_alf + c_SO(b1);    _RO1:=c_RO(b1)  endend;procedure conus2_BL_XY(b,l: Double; out x,y: Double);begin  conus_ru_BL_XY(b,l, conus2, x,y)end;procedure conus2_XY_BL(x,y: Double; out b,l: Double);begin  conus_ru_XY_BL(x,y, conus2, b,l)end;var  conus3: RC_ru;procedure conus3_Init(b1,b2,l1: Double);var  bc, r1,r2,rc, s1,s2,sc: Extended;begin  with conus3 do  if (_B1 <> b1)  or (_B2 <> b2)  or (_L1 <> l1) then begin    _B1:=b1; _B2:=b2; _L1:=l1;    conus_b2(b1,b2); bc:=(b1+b2)/2;    r1:=c_RO(b1); r2:=c_RO(b2); rc:=c_RO(bc);    s1:=c_SO(b1); s2:=c_SO(b2); sc:=c_SO(bc);    _C:=(r2*s1-r1*s2)/(r2-r1);    _alf:=Sqrt(r2*rc/((_C-sc)*(_C-s2)));    _alf:=0.850966;    _RO1:=c_RO(b1)  endend;procedure conus3_BL_XY(b,l: Double; out x,y: Double);begin  conus_ru_BL_XY(b,l, conus3, x,y)end;procedure conus3_XY_BL(x,y: Double; out b,l: Double);begin  conus_ru_XY_BL(x,y, conus3, b,l)end;var  conus4: record     _alf,_RO1: Extended;     _B1,_B2,_L1: Double;   end;procedure conus4_Init(b1,b2,l1: Double);var  teta: Extended;begin  with conus4 do  if (_B1 <> b1)  or (_B2 <> b2)  or (_L1 <> l1) then begin    _B1:=b1; _B2:=b2; _L1:=l1;    conus_b2(b1,b2); teta:=(b2-b1)/2;    _alf:=Sin(b1/2+b2/2) * Cos(teta) / Cos(teta/2);    _RO1:=c_RO(b1)  endend;procedure conus4_BL_XY(b,l: Double; out x,y: Double);var  p,dl, sin,cos: Extended;begin  with conus4 do begin    p:=c_RO(b_Range(b));    dl:=conus_dl(l,_L1);    SinCos(_alf*dl, sin,cos);    x:=_RO1 - p*cos; y:=p*sin;  endend;procedure conus4_XY_BL(x,y: Double; out b,l: Double);var  p,dp,fi,df,old,grad: Extended; i: Integer;begin  with conus4 do begin    x:=_RO1 - x; grad:=Pi/180;    if Abs(x) < 0.1 then l:=_L1 else    l:=ArcTan2(y,x)/_alf + _L1  end;  p:=Hypot(x,y); dp:=0;  if Abs(p) >=c_.A then fi:=0 else  fi:=ArcCos(p/c_.A);  for i:=1 to 1024 do begin    old:=dp; dp:=p-c_RO(fi);    if Abs(dp) > 111000 then begin      if (old < 0) <> (dp < 0) then      grad:=grad/2; df:=grad;      if dp < 0 then df:=-df;    end else    if Abs(dp) > 0.1 then      df:=dp/30/36000*grad    else      Break;    if fi < 0 then df:=-df;    fi:=fi - df  end;  b:=fiend;procedure pc_BL_XY(b,l, L0: Double; out x,y: Double);var  temp,dX, NR, ro, sinphi,cosphi: Extended;  delt: Extended; Sign: Boolean;begin  Sign:=b < 0; b:=Abs(b); dX:=c_SO(b);  SinCos(b, sinphi,cosphi);  temp:= 1.0 - c_.Es * Sqr(sinPhi);  NR:=c_.a / Sqrt(temp);  if Abs(b) < 0.00001 then begin   x:=dX; y:=NR*(L-L0);  end  else begin    ro:=NR*cosphi/sinPhi;    delt:=(L-L0)*sinphi;    x:=dX+ro*(1-cos(delt));    y:=ro*sin(Delt)  end;  if Sign then x:=-xend;function pc_XY_BL(X,Y, L0: double; out B,L: double): Integer;var  tgc: TGauss; Sign: Boolean;  tau, Fi,Lpr, db,dl: double;begin  Sign:=X < 0; X:=Abs(X);  gk_XY_BL(X,Y, L0, Fi,Lpr); Lpr:=Lpr - L0;  tau:=1.9e-7;  for Result:=1 to 1024 do begin    pc_BL_XY(fi,Lpr,0,tgc.x,tgc.y);    dl:=tau*(y-tgc.y); Lpr:=Lpr+dl;    db:=tau*(x-tgc.x); fi:=fi+db;    if Max(ABS(db),ABS(dl)) < Small then Break  end;  if Sign then Fi:=-Fi;  B:=Fi; L:=Lpr+L0;end;const  _Small = 1.e-12;function phi_Range(B: Double; B1,B2: Integer): Double;var  _B1,_B2: Double;begin  B:=Abs(B); _B1:=B1/180*Pi; _B2:=B2/180*Pi;  Result:=Min(Max(B,_B1),_B2)end;function back_sin(cos: Extended): Extended;begin  if Abs(cos) > 1-_Small then Result:=0  else Result:=Sqrt(1 - cos*cos)end;function stereo_u(B: Double): Extended;var  w,f: Extended;begin  w:=c_.E * Sin(B); f:=Pi_4 + B/2;  Result:=Tan(f) * Power((1-w)/(1+w),c_.E/2);end;function norm_usm(Phi,k0: Extended): Extended;var  w,f,u: Extended;begin  w:=c_.E * Sin(Phi); f:=pi_4 + Phi*0.5;  if Abs(f-Pi_2) < _Small then begin    u:=Cotan(f) * Power((1+w)/(1-w),0.5*c_.E);    Result:=2 * Arctan2(1/k0,U) - Pi_2;  end  else begin    u:=Tan(f) * Power((1-w)/(1+w),0.5*c_.E);    Result:=2 * Arctan(u/k0) - Pi_2;  end;end;function cross_usm(Phi,k0,alf: Extended): Extended;var  w,f,u: Extended;begin  w:=c_.E * Sin(Phi); f:=Pi_4 + Phi/2;  u:=Tan(f) * Power((1-w)/(1+w),c_.E/2);  Result:=2 * Arctan(k0 * Power(u,alf)) - Pi_2;end;function pole_usm(phi,k0: Extended): Extended;var  w,f,u: Extended;begin  w:=c_.E*Sin(phi); f:=Pi_4 + phi/2;  u:=Cotan(f) * Power((1+w)/(1-w),c_.E/2);  Result:=2 * Arctan2(1/k0,u) - Pi_2end;function back_pole(usm,k0: Extended): Double;var  phi,db,tau,usm_: Extended;  loop: Integer;begin  phi:=usm; tau:=1;  for loop:=1 to 100000 do begin    usm_:=pole_usm(phi,k0);    db:=tau*(usm-usm_); Phi:=Phi + db;    if Abs(db) < _Small then Break  end;  Result:=Phiend;function back_norm(usm,k0: Extended): Double;var  phi,db,tau,usm_: Extended;  loop: Integer;begin  phi:=usm; tau:=1;  for loop:=1 to 100000 do begin    usm_:=norm_usm(phi,k0);    db:=tau*(usm-usm_); Phi:=Phi + db;    if Abs(db) < _Small then Break  end;  Result:=Phiend;function back_cross(sinPhi,k0,alf: Extended): Double;var  phi,db,tau,usm,usm_: Extended;  loop: Integer;begin  usm:=Arcsin(sinPhi);  phi:=usm; tau:=1;  for loop:=1 to 100000 do begin    usm_:=cross_usm(phi, k0,alf);    db:=tau*(usm-usm_); phi:=phi + db;    if Abs(db) < _Small then Break  end;  Result:=phiend;function ro_SinCos(X,Y: Double;                   out sinA,cosA: Extended): Extended;begin  Result:=Hypot(X,Y);  if Result > small then begin    sinA:=Y/Result; cosA:=X/Result;  end  else begin    sinA:=0; cosA:=1  end;end;// Поперечная равноугольная цилиндрическая Меркатораvar  mCross: record    _k0,_r0: Extended; _Bn: Double;  end;procedure Mcross_Init(Bn: Double);var  sb,cb, ne,n, u,u0: Extended;begin  with mCross do  if Bn <> _Bn then begin    Bn:=phi_Range(Bn,45,85);        _Bn:=Bn; SinCos(Bn, sb,cb);    ne:=1 - c_.Es * sb * sb;    u0:=Pi_2 - Arctan(Sqrt(ne/(1 - c_.Es)) * (cb/sb) );    u:=stereo_u(Bn);    _k0:=Cotan(PI_4 + u0*0.5) * u;    n:=c_.A/Sqrt(ne); _r0:=n * cb/Cos(u0);  endend;procedure mCross_BL_XY(B,L: Double; out X,Y: Double);var  usm, cl,sl, kvB,kvL: extended;begin  SinCos(L,sl,cl);  with mCross do begin    usm:=pole_usm(B,_k0);    kvB:=Arcsin(-Cos(usm) * cl);  //z    kvL:=Arctan(CoTan(usm) * sl); //a    Y:=_r0 * kvL;    X:=_r0 * Ln(Tan(pi_4 + 0.5*kvB))  endend;procedure mCross_XY_BL(X,Y: Double; out B,L: Double);var  loop: Integer; r0,usm,kvB,kvL: Extended;begin  r0:=mCross._r0;  kvB:=2.0*Arctan(Exp(X/R0))-Pi_2; kvL:=Y/R0;  usm:=Arcsin(cos(kvb)*cos(kvl));  if (Abs(kvB) < _Small) and     (Abs(kvL) < _Small) then    L:=0  else    L:=Arctan2(sin(kvL),-Tan(kvB));  B:=back_pole(usm,mCross._k0)end;type  tilted_ctrl = record    L0_alf,_Rn,_k0,_alf,_sinu0,_cosu0: Extended;    _Bn,_B0,_L0: Double;  end;procedure tilted_Init(var ctrl: tilted_ctrl; Bn,B0,L0: Double);var  sb, ne,ne_2, u,u0, n,m,sfern: Extended;begin  with ctrl do  if (_Bn <> Bn)  or (_B0 <> B0)  or (_L0 <> L0) then begin    _Bn:=Bn; _B0:=B0; _L0:=L0;    sb:=Sin(Bn);    ne:=1 - c_.Es * sb * sb; ne_2:=Sqrt(ne);    n:=c_.a / ne_2;  m:=n * (1 - c_.Es) / ne;    _Rn:=Sqrt(m*n);    sfern:=Arctan(_Rn / n * Tan(Bn));    _alf:=1/Sqrt(1 - c_.Es);    if Abs(sfern) > Small then    _alf:=sb / Sin(sfern);    u:=stereo_u(Bn);    _k0:=Tan(Pi_4 + sfern*0.5) / Power(u,_alf);    u:=stereo_u(B0);    u0:=2 * Arctan(_k0 * Power(u,_alf)) - Pi_2;    L0_alf:=l0 * _alf; SinCos(u0, _sinu0,_cosu0);  endend;// Азимутальная косая стереографическаяvar  tStereo: tilted_ctrl;procedure tStereo_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindW,cosdw, ro: Extended;begin  with tStereo do begin    usm:=cross_usm(B,_k0,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    ro:=2 * _Rn / (1 + _sinu0*sinu + _cosu0*cosu*cosdw);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindW * ro;  endend;procedure tStereo_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, Phi: Extended;  tanzet,tanzet2,sinzet,cosZet,sinPhi,tandw: Extended;begin  ro:=ro_SinCos(X,Y, sinA,cosA);  with tStereo do begin    tanzet:=ro / (2 * _Rn);    tanzet2:=Sqr(tanzet);    sinZet:=2*tanzet/(1 + tanzet2);    cosZet:=(1 - tanzet2)/(1 + tanzet2);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=(L0_alf + Arctan(tandw))/_alf;    B:=back_cross(sinPhi, _k0,_alf)  endend;type  tpole_ctrl = record    _u0,_k0,_Rn: Extended;    _sinu0,_cosu0: Extended;    _Bn,_L0: Double;  end;procedure pole_Init(var ctrl: tpole_ctrl; Bn,L0: Double);var  sb,cb,ne, u,n: Extended;begin  with ctrl do  if (_Bn <> Bn)  or (_L0 <> L0) then begin    _Bn:=Bn; _L0:=L0;    SinCos(Bn,sb,cb); ne:=1 - c_.Es * sb * sb;    _u0:=Pi_2 - Arctan(Sqrt(ne/(1-c_.Es)) * (cb/sb));    u:=stereo_u(Bn);    _k0:=Cotan(Pi_4 + _u0*0.5) * u;    n:=c_.A/Sqrt(ne); _Rn:=n * cb / Cos(_u0);    SinCos(_u0,_sinu0,_cosu0);  endend;// Азимутальная косая стереографическая (полюс)var  pStereo: tpole_ctrl;procedure pStereo_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, ro: Extended;begin  with pStereo do begin    usm:=pole_usm(B,_k0);    SinCos(usm,sinu,cosu);    SinCos(L - _L0,sindw,cosdw);    ro:=2 * _Rn / (1 + _sinu0*sinu + _cosu0*cosu*cosdw);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindw * ro  endend;procedure pStereo_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, tanzet,tanzet2: Extended;  sinzet,cosZet,sinPhi,tandw: Extended;begin  with pStereo do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    tanzet:=ro / (2*_Rn);    tanzet2:=Sqr(tanzet);    sinZet:=2 * tanzet/(1 + tanzet2);    cosZet:=(1 - tanzet2)/(1 + tanzet2);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=_L0 + Arctan(tandw);    B:=back_pole( Arcsin(sinPhi),_k0 );  endend;type  tnorm_ctrl = record    _k0,_Rn: Extended;    _Bn,_L0,_Sign: Double;  end;procedure norm_Init(var ctrl: tnorm_ctrl; Bn,L0,Sign: Double);var  sb,cb, n,ne, u,u0: Extended;begin  with ctrl do  if (_Bn <> Bn)  or (_L0 <> L0) then begin    Bn:=phi_Range(Bn,10,80);    _Bn:=Bn; _L0:=L0; _Sign:=Sign;    SinCos(Bn, sb,cb);    ne:=1 - c_.Es * sb * sb;    u0:=Pi_2 - Arctan(Sqrt(ne /(1-c_.Es)) * (cb/sb));    u:=stereo_u(Bn);    _k0:=Cotan(PI_4 + u0*0.5) * u;    n:=c_.A/Sqrt(ne); _Rn:=n * cb/Cos(u0);  endend;// Азимутальная нормальная,зеркальная стереографическаяvar  nStereo: tnorm_ctrl;  mStereo: tnorm_ctrl;procedure nStereo_BL_XY(B,L: Double; out X,Y: Double);var  c,s, usm, ro: Extended;begin  with nStereo do begin    usm:=pole_usm(B,_k0);    SinCos(usm, s,c);    ro:=2 * _Rn * c / (1 + s);    SinCos(L - _L0, s,c);    X:=ro * c * _Sign; Y:=ro * s;  endend;procedure nStereo_XY_BL(X,Y: Double; out B,L: Double);var  usm,ro: Extended;begin  with nStereo do begin    X:=X * _Sign; ro:=Hypot(X,Y);    if ro = 0 then      B:=Pi_2    else begin      usm:=Pi_2 - 2*Arctan(ro/(_Rn*2));      B:=back_pole(usm,_k0)    end;    L:=_L0 + Arctan2(Y,X);  endend;// Азимутальная нормальная,зеркальная гномоническаяvar  nGnomon: tnorm_ctrl;  mGnomon: tnorm_ctrl;procedure nGnomon_BL_XY(B,L: Double; out X,Y: Double);var  c,s, usm,ro: extended;begin  with nGnomon do begin    usm:=norm_usm(B,_k0);    ro:=_Rn * Cotan(usm);    SinCos(L - _L0, s,c);    X:=ro * c * _Sign; Y:=ro * s  endend;procedure nGnomon_XY_BL(X,Y: Double; out B,L: Double);var  usm,ro: extended;begin  with nGnomon do begin    X:=X * _Sign; ro:=Hypot(X,Y);    if ro = 0 then      B:=Pi_2    else begin      usm:=Arctan2(_Rn,ro);      B:=back_norm(usm,_k0)    end;    L:=_L0 + Arctan2(Y,X)  endend;type  tcross_ctrl = record    _Rn,_alf,L0_alf: Extended;    _L0: Double;  end;procedure cross_Init(var ctrl: tcross_ctrl; L0: Double);var  n,m: Extended;begin  with ctrl do  if L0 <> _L0 then begin    n:=c_.A; m:=c_.A *(1 - c_.Es);    _Rn:=Sqrt(m*n);    _alf:=1 / Sqrt(1 - c_.Es);    L0_alf:=_alf * L0; _L0:=L0  endend;// Азимутальная поперечная стереографическаяvar  cStereo: tcross_ctrl;procedure cStereo_BL_XY(B,L: Double; out X,Y: double);var  usm,sinu,cosu,sindw,cosdw, ro: Extended;begin  with cStereo do begin    usm:=cross_usm(B,1,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    ro:=2*_Rn /(1 + cosu*cosdw);    X:=sinu * ro;    Y:=cosu*sindw * ro  endend;procedure cStereo_XY_BL(X,Y: Double; out B,L: Double);var  ro, sinA,cosA, tanzet,tanzet2: Extended;  sinzet,cosZet,sinPhi,tandw: Extended;begin  with cStereo do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    tanzet:=ro / (2*_Rn);    tanzet2:=Sqr(tanzet);    sinZet:=2 * tanzet/(1 + tanzet2);    cosZet:=(1 - tanzet2)/(1 + tanzet2);    sinPhi:=sinZet*CosA;    tandw:=sinZet*sinA/cosZet;    L:=(L0_alf + arctan(tandw))/_alf;    B:=back_cross(sinPhi,1,_alf)  endend;// Азимутальная поперечная гномоническаяvar  cGnomon: tcross_ctrl;procedure cGnomon_BL_XY(B,L: Double; out X,Y: double);var  usm,sinu,cosu,sindw,cosdw, ro: Extended;begin  with cGnomon do begin    usm:=cross_usm(B,1,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    ro:=_Rn/(cosu*cosdw);    X:=sinu * ro;    Y:=cosu * sindw * ro;  endend;procedure cGnomon_XY_BL(X,Y: Double; out B,L: Double);var  ro, sinA,cosA, zet,sinzet,cosZet,sinPhi,tandw: Extended;begin  ro:=ro_SinCos(X,Y, sinA,cosA);  with cGnomon do begin    zet:=Arctan(ro/_Rn);    SinCos(zet,sinZet,CosZet);    sinPhi:=sinZet*CosA;    tandw:=sinZet*sinA/cosZet;    L:=(L0_alf + Arctan(tandw))/_alf;    B:=back_cross(sinPhi,1,_alf)  endend;// Азимутальная косая гномоническаяvar  tGnomon: tilted_ctrl;procedure tGnomon_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, ro: extended;begin  with tGnomon do begin    usm:=cross_usm(B,_k0,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    ro:=_Rn / (_sinu0*sinu + _cosu0*cosu*cosdw);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindw * ro;  endend;procedure tGnomon_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA,zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with tGnomon do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    zet:=Arctan(ro/_Rn);    SinCos(zet,sinZet,CosZet);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=(L0_alf + arctan(tandw))/_alf;    B:=back_cross(sinPhi,_k0,_alf)  endend;// Азимутальная косая гномоническая (полюс)var  pGnomon: tpole_ctrl;procedure pGnomon_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, ro: extended;begin  with pGnomon do begin    usm:=pole_usm(B,_k0);    SinCos(usm,sinu,cosu);    SinCos(L - _L0,sindw,cosdw);    ro:=_Rn/(_sinu0*sinu + _cosu0*cosu*cosdw);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindW * ro  endend;procedure pGnomon_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with pGnomon do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    zet:=Arctan(ro/_Rn);    SinCos(zet,sinZet,CosZet);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=_L0 + Arctan(tandw);    B:=back_pole( Arcsin(sinPhi),_k0)  endend;// Азимутальная косая равнопромежуточная Постеляvar  tPostel: tilted_ctrl;procedure tPostel_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, zet,ro: extended;begin  with tPostel do begin    usm:=cross_usm(B,_k0,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    Zet:=Arccos(_sinu0*sinu + _cosu0*cosu*cosdw);    ro:=_Rn*zet/Sin(zet);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindw * ro;  endend;procedure tPostel_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, Zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with tPostel do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    Zet:=ro/_Rn;    SinCos(Zet, sinZet,cosZet);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=(L0_alf + Arctan(tandw))/_alf;    B:=back_cross(sinPhi,_k0,_alf)  endend;// Азимутальная косая равнопромежуточная Постеля (полюс)var  pPostel: tpole_ctrl;procedure pPostel_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, zet,ro: extended;begin  with pPostel do begin    usm:=pole_usm(B,_k0);    SinCos(usm,sinu,cosu);    SinCos(L - _L0,sindw,cosdw);    Zet:=Arccos(_sinu0*sinu + _cosu0*cosu*cosdw);    ro:=_Rn*zet/Sin(zet);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindW * ro;  endend;procedure pPostel_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, Zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with pPostel do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    Zet:=ro/_Rn;    SinCos(Zet, sinZet,cosZet);    SinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=_L0 + arctan(tandw);    B:=back_pole( Arcsin(sinPhi),_k0)  endend;// Азимутальная нормальная,зеркальная равнопромежуточная Постеляvar  nPostel: tnorm_ctrl;  mPostel: tnorm_ctrl;procedure nPostel_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu,sindw,cosdw, zet,ro: Extended;begin  with nPostel do begin    usm:=pole_usm(B,_k0);    SinCos(usm,sinu,cosu);    SinCos(L - _L0,sindw,cosdw);    Zet:=Pi_2-usm;    ro:=_Rn*zet/Sin(zet);    X:=-cosu*cosdw * ro * _Sign;    Y:=cosu*sindW * ro;  endend;procedure nPostel_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, Zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with nPostel do begin    X:=X * _Sign;    ro:=ro_SinCos(X,Y, sinA,cosA);    Zet:=ro/_Rn;    SinCos(Zet, sinZet,cosZet);    sinPhi:=cosZet;    tandw:=sinZet*sinA /(-sinZet*CosA);    L:=_L0 + arctan(tandw);    B:=back_pole( Arcsin(sinPhi),_k0)  endend;// Азимутальная поперечная равнопромежуточная Постеляvar  cPostel: tcross_ctrl;procedure cPostel_BL_XY(B,L: Double; out X,Y: Double);var  usm,sinu,cosu, sindW,cosdw, Zet,ro: extended;begin  with cPostel do begin    usm:=cross_usm(B,1,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    Zet:=Arccos(cosu*cosdw);    ro:=_Rn*zet/Sin(zet);    X:=sinu * ro;    Y:=cosu*sindW * ro;  endend;procedure cPostel_XY_BL(X,Y: Double; out B,L: Double);var  ro,sinA,cosA, zet,sinzet,cosZet,sinPhi,tandw: extended;begin  with cPostel do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    Zet:=ro/_Rn;    SinCos(Zet, sinZet,cosZet);    sinPhi:=sinZet*CosA;    tandw:=sinZet*sinA/cosZet;    L:=(L0_alf + Arctan(tandw))/_alf;    B:=back_cross(sinPhi,1,_alf)  endend;// Азимутальная косая равновеликая Ламбертаvar  sLambert: record    _Rn,_Rn2, _sinu0,_cosu0: Extended;    _B0,_L0: Double;  end;function Lambert_S(b: Double): Extended;var  sb,esb, Es2: Extended;begin  sb:=Sin(b); esb:=sb * c_.Es; Es2:=Sqr(c_.Es);  Result:=0.5*Sqr(c_.A)*(1-Es2)*(sb/(1-Sqr(esb)) +          0.5/c_.Es*Ln((1+esb)/(1-esb)))end;procedure sLambert_Init(B0,L0: Double);begin  with sLambert do  if (B0 <> _B0)  or (L0 <> _L0) then begin _B0:=B0; _L0:=L0;    _Rn2:=0.5*Sqr(c_.A)*(1 + (1 - 0.5*c_.Es*Ln((1+c_.es)/(1-c_.es))));    _Rn:=Sqrt(_Rn2);    _sinu0:=Lambert_S(B0) / _Rn2;    _cosu0:=back_sin(_sinu0)  endend;procedure sLambert_BL_XY(B,L: Double; out X,Y: Double);var  sinu,cosu,sindw,cosdw, zet,ro: extended;begin  with sLambert do begin    sinu:=Lambert_S(B)/ _Rn2;    cosu:=back_sin(sinu);    SinCos(L - _L0,sindw,cosdw);    Zet:=Arccos(_sinu0*sinu + _cosu0*cosu*cosdw);    ro:=2*_Rn*Sin(Zet/2)/Sin(Zet);    X:=(_cosu0*sinu - _sinu0*cosu*cosdw) * ro;    Y:=cosu*sindw * ro;  endend;procedure sLambert_XY_BL(X,Y: Double; out B,L: Double);var  ro, sinA,cosA,Zet,sinzet,cosZet,sinPhi,tandw: Extended;  loop: Integer; usm,usm_,tau,db,Phi: Extended;begin  with sLambert do begin    ro:=ro_SinCos(X,Y, sinA,cosA);    Zet:=2*Arcsin(ro/(2*_Rn));    SinCos(Zet, sinZet,cosZet);    sinPhi:=cosZet*_sinu0 + sinZet*_cosu0*CosA;    tandw:=sinZet*sinA/(cosZet*_cosu0 - sinZet*_sinu0*CosA);    L:=(_L0 + Arctan(tandw));    Phi:=Arcsin(sinPhi);    usm:=Phi; tau:=1;    for loop:=1 to 100000 do begin      usm_:=Arcsin(Lambert_S(Phi) / _Rn2);      db:=tau*(usm-usm_); Phi:=Phi + db;      if Abs(db) < _Small then Break    end;    B:=Phi;  endend;type  tcylps = record    tilted: tilted_ctrl;    _sinZ0,_C,_D: Extended;  end;procedure cylps_init(var ctrl: tcylps; Bn,B0,L0,Z0,D: Double);begin  with ctrl do begin    tilted_Init(tilted, Bn,B0,L0);    _sinZ0:=Sin(Z0); _C:=D + _sinZ0; _D:=D  endend;// Косая перспективно-цилиндрическая проекцияvar  cylps1: tcylps; // ЦНИИГАИКа  cylps2: tcylps; // Соловьеваprocedure cylps_BL_XY(B,L: Double;                      const ctrl: tcylps;                      out X,Y: Double);var  usm, sinu,cosu, sindw,cosdw: Extended;  cosZet,sinZet, sinA,cosA,A: Extended;begin  with ctrl,tilted do begin    usm:=cross_usm(B,_k0,_alf);    SinCos(usm,sinu,cosu);    SinCos(L*_alf - L0_alf,sindw,cosdw);    CosZet:=_sinu0*sinu + _cosu0*cosu*cosdw;    SinZet:=back_sin(cosZet);    cosA:=_cosu0*sinu - _sinu0*cosu*cosdw;    sinA:=cosu*sindw;    A:=Arctan2(sinA,cosA);    X:=_C * _Rn * cosZet / (_D + sinZet);    Y:=-_Rn * _sinZ0 * A;  endend;procedure cylps_XY_BL(X,Y: Double;                      const ctrl: tcylps;                      out B,L: double);var  A,sinA,cosA,cosZet,sinZet,sinPhi: Extended;  Xnorm,X_,tau,db,dw: Extended; i: Integer;begin  with ctrl,tilted do begin    A:=-Y / (_Rn * _sinZ0);    SinCos(A,sinA,cosA);    Xnorm:=X / (_C * _Rn);    cosZet:=Xnorm * _D;    tau:=1;    for i:=1 to 100000 do begin      sinZet:=back_sin(cosZet);      X_:=cosZet/(_D + sinZet);      db:=tau * (Xnorm - X_);      cosZet:=cosZet + db;      if  Abs(db) < _Small then Break    end;    sinZet:=back_sin(cosZet);    sinPhi:=cosZet * _sinu0 + sinZet*_cosu0*CosA;    dw:=Arctan2(sinZet*sinA,cosZet*_cosu0 - sinZet*_sinu0*CosA);    if dw < 0 then dw:=dw + pi2;    L:=(L0_alf + dw)/_alf;    B:=back_cross(sinPhi, _k0,_alf)  endend;const  bl_comf = 10000000;  ms_comf = 3600000;procedure BL_to_XY(b,l, lc,b1,b2: double; elp,prj: byte; var x,y: double); stdcall;begin  c_:=Ellipsoids[elp_(elp)];  case prj of0,1:  gk_BL_XY(b,l,lc,x,y);2:  begin      gk_BL_XY(b,l,lc,x,y);      x:=x*0.9996; y:=y*0.9996;    end;3:  m_BL_XY(b,l,b1,x,y);4:  begin      conus1_Init(b1,b2,lc);      conus1_BL_XY(b,l, x,y);    end;5:  begin     { avia_Init(b1,lc,c_.A);      avia_BL_XY(b,l, x,y)      }    end;6:  pc_BL_XY(b,l, lc, x,y);7:  begin      conus2_Init(b1,b2,lc);      conus2_BL_XY(b,l, x,y);    end;8:  begin      conus3_Init(b1,b2,lc);      conus3_BL_XY(b,l, x,y);    end;9:  begin      Mcross_Init(b1);      mCross_BL_XY(b,l, x,y);    end;10: begin      tilted_Init(tStereo, b1,b2,lc);      tStereo_BL_XY(b,l, x,y);    end;11: begin      pole_Init(pStereo, b1,lc);      pStereo_BL_XY(b,l, x,y);    end;12: begin      norm_Init(nStereo, b1,lc,1);      nStereo_BL_XY(b,l, x,y);    end;13: begin      norm_Init(nStereo, b1,lc,-1);      nStereo_BL_XY(b,l, x,y);    end;14: begin      norm_Init(nGnomon, b1,lc,1);      nGnomon_BL_XY(b,l, x,y);    end;15: begin      norm_Init(nGnomon, b1,lc,-1);      nGnomon_BL_XY(b,l, x,y);    end;16: begin      cross_Init(cStereo, lc);      cStereo_BL_XY(b,l, x,y);    end;17: begin      cross_Init(cGnomon, lc);      cGnomon_BL_XY(b,l, x,y);    end;18: begin      tilted_Init(tGnomon, b1,b2,lc);      tGnomon_BL_XY(b,l, x,y);    end;19: begin      pole_init(pGnomon, b1,lc);      pGnomon_BL_XY(b,l, x,y);    end;20: begin      tilted_Init(tPostel, b1,b2,lc);      tPostel_BL_XY(b,l, x,y);    end;21: begin      pole_Init(pPostel, b1,lc);      pPostel_BL_XY(b,l, x,y);    end;22: begin      norm_Init(nPostel, b1,lc,1);      nPostel_BL_XY(b,l, x,y);    end;23: begin      norm_Init(nPostel, b1,lc,-1);      nPostel_BL_XY(b,l, x,y);    end;24: begin      cross_Init(cPostel, lc);      cPostel_BL_XY(b,l, x,y);    end;25: begin      sLambert_Init(b1,lc);      sLambert_BL_XY(b,l, x,y);    end;26: begin      tilted_Init(cylps1.tilted, b1,b2,lc);      cylps_BL_XY(b,l, cylps1, x,y);    end;27: begin      tilted_Init(cylps2.tilted, b1,b2,lc);      cylps_BL_XY(b,l, cylps2, x,y);    end;28: begin      x:=b * (180/Pi) * ms_comf;      y:=l * (180/Pi) * ms_comf    end;29: begin      x:=b * (180/Pi) * bl_comf;      y:=l * (180/Pi) * bl_comf    end;  endend;procedure XY_to_BL(x,y, lc,b1,b2: double; elp,prj: byte; var b,l: double); stdcall;begin  c_:=Ellipsoids[elp_(elp)];  case prj of0,1:  gk_XY_BL(x,y,lc,b,l);2:  begin      x:=x/0.9996; y:=y/0.9996;      gk_XY_BL(x,y,lc,b,l);    end;3:  m_XY_BL(x,y,b1,b,l);4:  begin      conus1_Init(b1,b2,lc);      conus1_XY_BL(x,y, b,l);    end;5:  begin     {      avia_Init(b1,lc,c_.A);      avia_XY_BL(x,y, b,l)     }    end;6:  pc_XY_BL(x,y, lc, b,l);7:  begin      conus2_Init(b1,b2,lc);      conus2_XY_BL(x,y, b,l);    end;8:  begin      conus3_Init(b1,b2,lc);      conus3_XY_BL(x,y, b,l);    end;9:  begin      Mcross_Init(b1);      mCross_XY_BL(x,y, b,l);    end;10: begin      tilted_Init(tStereo, b1,b2,lc);      tStereo_XY_BL(x,y, b,l);    end;11: begin      pole_Init(pStereo, b1,lc);      pStereo_XY_BL(x,y, b,l);    end;12: begin      norm_Init(nStereo, b1,lc,1);      nStereo_XY_BL(x,y, b,l);    end;13: begin      norm_Init(nStereo, b1,lc,-1);      nStereo_XY_BL(x,y, b,l);    end;14: begin      norm_Init(nGnomon, b1,lc,1);      nGnomon_XY_BL(x,y, b,l);    end;15: begin      norm_Init(nGnomon, b1,lc,-1);      nGnomon_XY_BL(x,y, b,l);    end;16: begin      cross_Init(cStereo, lc);      cStereo_XY_BL(x,y, b,l);    end;17: begin      cross_Init(cGnomon, lc);      cGnomon_XY_BL(x,y, b,l);    end;18: begin      tilted_Init(tGnomon, b1,b2,lc);      tGnomon_XY_BL(x,y, b,l);    end;19: begin      pole_init(pGnomon, b1,lc);      pGnomon_XY_BL(x,y, b,l);    end;20: begin      tilted_Init(tPostel, b1,b2,lc);      tPostel_XY_BL(x,y, b,l);    end;21: begin      pole_Init(pPostel, b1,lc);      pPostel_XY_BL(x,y, b,l);    end;22: begin      norm_Init(nPostel, b1,lc,1);      nPostel_XY_BL(x,y, b,l);    end;23: begin      norm_Init(nPostel, b1,lc,-1);      nPostel_XY_BL(x,y, b,l);    end;24: begin      cross_Init(cPostel, lc);      cPostel_XY_BL(x,y, b,l);    end;25: begin      sLambert_Init(b1,lc);      sLambert_XY_BL(x,y, b,l);    end;26: begin      tilted_Init(cylps1.tilted, b1,b2,lc);      cylps_XY_BL(x,y, cylps1, b,l);    end;27: begin      tilted_Init(cylps2.tilted, b1,b2,lc);      cylps_XY_BL(x,y, cylps2, b,l);    end;28:  begin      b:=b_Range(x / ms_comf / (180/Pi));      l:=y / ms_comf / (180/Pi);    end;29: begin      b:=b_Range(x / bl_comf / (180/Pi));      l:=y / bl_comf / (180/Pi);    end;  endend;function _fi(Grad: Integer): Double;begin  Result:=Grad/180*Piend;procedure xbl_init;var  f80,f60,f25,f45,f75: Double;begin  Ellipsoids_Init;  f80:=_fi(80); f60:=_fi(60);  f25:=_fi(25); f45:=_fi(45);  f75:=_fi(75);   Fillchar(conus1,Sizeof(conus1),0);  conus1_Init(1.11,1.22,0.5);  Fillchar(conus2,Sizeof(conus2),0);  conus2_Init(1.11,1.22,0.5);  Fillchar(conus3,Sizeof(conus3),0);  conus3_Init(1.11,1.22,0.5);  Fillchar(conus4,Sizeof(conus4),0);  conus4_Init(1.11,1.22,0.5);  Fillchar(Mcross,Sizeof(Mcross),0);  Mcross_Init(f80);  Fillchar(tStereo,Sizeof(tStereo),0);  tilted_Init(tStereo, f80,f60,f60);  Fillchar(pStereo,Sizeof(pStereo),0);  pole_init(pStereo, f80,f60);  Fillchar(nStereo,Sizeof(nStereo),0);  norm_Init(nStereo, f80,f60,1);  Fillchar(mStereo,Sizeof(mStereo),0);  norm_Init(mStereo, f80,f60,-1);  Fillchar(nGnomon,Sizeof(nGnomon),0);  norm_Init(nGnomon, f80,f60,1);  Fillchar(mGnomon,Sizeof(mGnomon),0);  norm_Init(mGnomon, f80,f60,-1);  Fillchar(cStereo,Sizeof(cStereo),0);  cross_Init(cStereo, f60);  Fillchar(cGnomon,Sizeof(cGnomon),0);  cross_Init(cGnomon, f60);  Fillchar(tGnomon,Sizeof(tGnomon),0);  tilted_Init(tGnomon, f80,f60,f60);  Fillchar(pGnomon,Sizeof(pGnomon),0);  pole_init(pGnomon, f80,f60);  Fillchar(tPostel,Sizeof(tPostel),0);  tilted_Init(tPostel, f80,f60,f60);  Fillchar(pPostel,Sizeof(pPostel),0);  pole_init(pPostel, f80,f60);  Fillchar(nPostel,Sizeof(nPostel),0);  norm_Init(nPostel, f80,f60,1);  Fillchar(mPostel,Sizeof(mPostel),0);  norm_Init(mPostel, f80,f60,-1);  Fillchar(cPostel,Sizeof(cPostel),0);  cross_Init(cPostel,f60);  Fillchar(sLambert,Sizeof(sLambert),0);  sLambert_Init(f80,f60);  Fillchar(cylps1,Sizeof(cylps1),0); // ЦНИИГАИКа  cylps_init(cylps1,f60,f25,-f80,f80,3);  Fillchar(cylps2,Sizeof(cylps2),0); // Соловьева  cylps_init(cylps2,f60,f75,-f80,f45,1);end;initialization xbl_Init;end.